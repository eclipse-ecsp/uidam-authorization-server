server.port= ${SPRING_AUTH_PROXY_PORT_HTTPS:9443}

# The format used for the keystore. It could be set to JKS in case it is a JKS file
server.ssl.enabled= true
# The alias mapped to the certificate
server.ssl.key-alias= ${KEYSTORE_ALIAS:uidam-dev}
server.ssl.key-store-type=JKS
# The path to the keystore containing the certificate
server.ssl.key-store= ${KEYSTORE_FILE_NAME:uidamauthserver.jks}
# The password used to generate the certificate
server.ssl.key-store-password= ${KEYSTORE_PASS:uidam-test-pwd}
server.http.port= ${SPRING_AUTH_PROXY_PORT:9000}
uidam.default.db.schema=${UIDAM_DEFAULT_DB_SCHEMA:uidam}
spring.liquibase.enabled=true
uidam.liquibase.change-log.path=classpath:database.schema/master.xml
spring.datasource.type=com.zaxxer.hikari.HikariDataSource
#spring.liquibase.change-log=classpath:database.schema/master.xml

spring.jpa.properties.hibernate.default_schema=${UIDAM_DEFAULT_DB_SCHEMA:uidam}
#spring.liquibase.default-schema=${uidam.default.db.schema}
#spring.liquibase.parameters.schema=${uidam.default.db.schema}
spring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl

spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.show-sql=false

# This will create table automatically in your database
spring.jpa.hibernate.ddl-auto=none
spring.thymeleaf.enabled=true

spring.thymeleaf.prefix=${UI_TEMPLATE_PATH:classpath:/templates/}
spring.thymeleaf.check-template-location=true
spring.thymeleaf.check-template=true
spring.web.resources.static-locations=${UI_STATIC_PATH:classpath:/static}
#jwt.signing.key= ymLTU8rq83j4fmJZj60wh4OrMNuntIj4fmJ

user.management.base.url=${USER_MANAGEMENT_ENV:http://localhost:8080}

#ignite.oauth2.issuer.port= ${SPRING_AUTH_PROXY_PORT_HTTPS:9443}
ignite.oauth2.issuer.protocol= https
ignite.oauth2.issuer.host= ${SPRING_AUTH_PROXY_HOSTNAME:localhost:9443}
ignite.oauth2.issuer.prefix= ${SPRING_AUTH_PROXY_PREFIX:}
#allowed bcrypt strength [high, medium, low]
security.client.bcrypt.strength= ${SECURITY_CLIENT_BCRYPT_STRENGTH:high}
#server.servlet.context-path=${SERVER_SERVLET_CONTEXT_PATH:}
cleanup.job.batch.size=${CLEANUP_JOB_BATCH_SIZE:50000}
cleanup.job.scheduling.rate.cron=${CLEANUP_JOB_SCHEDULING_RATE_CRON: 0 0 */6 * * *}
cleanup.job.scheduling.retry.attempts=${CLEANUP_JOB_SCHEDULING_RETRY_ATTEMPTS:3}
cleanup.token.expires.before=${CLEANUP_TOKEN_EXPIRES_BEFORE_IN_DAYS:1}

ignite.oauth2.jks-enabled= ${JKS_ENABLED:true}
uidam.oauth2.token.hash.algorithm=${UIDAM_OAUTH2_TOKEN_HASH_ALGORITHM:SHA-256}
uidam.oauth2.token.hash.salt=${UIDAM_OAUTH2_TOKEN_HASH_SALT:ChangeMe}


#Cache configuration
cache.expire.mins=60
cache.max.size=100
cache.client.ids=token-mgmt,device-mgmt

###Graylog Configuration###
APP_GRAYLOG_ENABLED : ${GRAYLOG_ENABLED:false}
APP_GRAYLOG_HOST : ${GRAYLOG_HOST:graylog.default.svc.cluster.local}
APP_GRAYLOG_PORT : ${GRAYLOG_PORT:12201}
APP_NEVER_BLOCK_FOR_GRAYLOG : ${NEVER_BLOCK_FOR_GRAYLOG:false}
APP_LOG_FOLDER : ${LOG_FOLDER:logs/}
APP_LOG_LEVEL : ${LOG_LEVEL:INFO}
APP_IGNITE_LOG_LEVEL : ${IGNITE_LOG_LEVEL:DEBUG}
APP_SVC_LOG_LEVEL : ${SVC_LOG_LEVEL:DEBUG}
APP_STORAGE_LOG_LEVEL : ${STORAGE_LOG_LEVEL:ERROR}
APP_SPRING_LOG_LEVEL : ${SPRING_LOG_LEVEL:ERROR}
postgres.jdbc.url=${POSTGRES_DATASOURCE:jdbc:postgresql://localhost:5432/uidam_management}
postgres.username=${POSTGRES_USERNAME:ChangeMe}
postgres.password=${POSTGRES_PASSWORD:ChangeMe}
postgres.driver.class.name=org.postgresql.Driver
postgres.pool.name=hikariConnectionPool
postgres.data-source-properties.cachePrepStmts=${postgres_data_source_properties_cachePrepStmts:true}
postgres.data-source-properties.prepStmtCacheSize=${postgres_data_source_properties_prepStmtCacheSize:250}
postgres.data-source-properties.prepStmtCacheSqlLimit=${postgres_data_source_properties_prepStmtCacheSqlLimit:2048}
postgres.max.idle.time=${postgres_max_idle_time:0}
postgres.min.pool.size=${postgres_min_pool_size:15}
postgres.max.pool.size=${postgres_max_pool_size:30}
postgres.connection.timeout.ms=${postgres_connection_timeout_ms:60000}
postgres.expected99thPercentileMs=${postgres_expected99thPercentileMs:60000}
postgres.datasource.create.retry.count=${postgres_create_retry_count:3}
postgres.datasource.retry.delay.ms=${postgres_retry_delay:30}
postgresdb.metrics.enabled= ${postgresdb_metrics_enabled:false}
postgresdb.metrics.executor.shutdown.buffer.ms= ${postgresdb_metrics_executor_shutdown_buffer_ms:2000}
postgresdb.metrics.thread.freq.ms= ${postgresdb_metrics_thread_freq_ms:5000}
postgresdb.metrics.thread.initial.delay.ms= ${postgresdb_metrics_thread_initial_delay_ms:2000}

metrics.prometheus.enabled=${metrics_prometheus_enabled:false}
prometheus.agent.port=${prometheus_agent_port:9100}
prometheus.agent.port.exposed=${prometheus_agent_port_exposed:9100}

service.name=uidam-authorization-server

sp.restart.on.failure=false


health.service.executor.initial.delay=10000
health.service.retry.interval.millis=120000
health.postgresdb.monitor.enabled= ${health_postgresdb_monitor_enabled:false}
health.postgresdb.monitor.restart.on.failure= ${health_postgresdb_monitor_restart_on_failure:false}

client.by.client.id.endpoint= ${CLIENT_BY_CLIENT_ID_ENDPOINT:/v1/oauth2/client/{clientId}}
user.by.username.endpoint= ${USER_BY_USERNAME_ENDPOINT:/v1/users/{userName}/byUserName}

account.name= ${ACCOUNT_NAME:ecsp}

account.field.enabled = ${ACCOUNT_FIELD_ENABLED:false}
#Fixed session timeout
server.servlet.session.timeout=5m
session.recreation.policy=IF_REQUIRED
#Force user to login always in Auth Code/PKCE flow
user.session.force.login=true

#CORS configuration
cors.allowed.origin.patterns=*.harmandev.com,*.harman.com
cors.allowed.methods=GET,HEAD,POST

# Logout redirect URI validation configuration
# Comma-separated list of whitelisted custom hosts for HTTP redirect URIs
# Only these hosts will be allowed for non-HTTPS redirect URIs during logout
logout.redirect.whitelisted.custom.hosts=${LOGOUT_REDIRECT_WHITELISTED_CUSTOM_HOSTS:localhost,127.0.0.1}

# Default tenant configuration (matches MultiTenantProperties.defaultTenantId)
tenant.default-tenant-id=${DEFAULT_TENANT_ID:ecsp}

spring.config.import=classpath:tenant-ecsp.properties,tenant-sdp.properties
tenant.default=${TENANT_DEFAULT:ecsp}
tenant.multitenant.enabled=${TENANT_MULTITENANT_ENABLED:false}
tenant.ids=${TENANT_IDS:ecsp,sdp}


#Actuators
management.endpoint.health.show-details=always
management.endpoint.health.probes.enabled=true
management.health.livenessState.enabled=true
management.health.readinessState.enabled=true
management.health.db.enabled=false
management.endpoint.health.access=read-only


# Management and Metrics Configuration
management.defaults.metrics.export.enabled=false

#Enable/Disable only prometheus metrics export
management.prometheus.metrics.export.enabled=${metrics_prometheus_enabled:false}
management.endpoints.web.path-mapping.prometheus=${metrics_prometheus_path:/prometheus}
management.endpoint.prometheus.access=read-only

#Enable/Disable only datadog metrics export
management.datadog.metrics.export.enabled=${metrics_datadog_enabled:false}
management.datadog.metrics.export.api-key=${metrics_datadog_apiKey:api-key}
#If you additionally provide an application key (optional), then metadata such as meter descriptions, types, and base units will also be exported
management.datadog.metrics.export.application-key=${metrics_datadog_applicationKey:applicationKey}
management.datadog.metrics.export.descriptions=${metrics_datadog_descriptions:true}
#If your Datadog project is hosted on one of the other sites, change the URL accordingly
management.datadog.metrics.export.uri=${metrics_datadog_uri:https://api.datadoghq.eu}
management.datadog.metrics.export.step=${metrics_datadog_step:30s}
management.datadog.metrics.export.read-timeout=${metrics_datadog_readTimeout:5s}
management.datadog.metrics.export.connect-timeout=${metrics_datadog_connectTimeout:5s}
management.datadog.metrics.export.batch-size=${metrics_datadog_batchSize:1000}
management.datadog.metrics.export.host-tag=${service.name}


management.endpoints.web.exposure.include=health,info,prometheus,metrics
management.server.port=${prometheus.agent.port}
management.endpoint.metrics.access=read-only
management.endpoints.access.default=none
management.endpoints.web.base-path=${metrics_basePath:/uidam-authorization-server}
management.endpoints.web.path-mapping.metrics=/metrics
management.endpoints.web.path-mapping.health=/health
management.endpoint.health.show-components=ALWAYS
management.endpoints.jmx.exposure.exclude=*
management.metrics.tags.application=${service.name}


